<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Cross The Yellow Line</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<style>
    @import url("https://fonts.googleapis.com/css?family=Press+Start+2P");
    @import url("https://fonts.googleapis.com/css2?family=Roboto:wght@400;700;900&display=swap");

    body { 
        margin: 0; overflow: hidden; background-color: #2c3e50; 
        font-family: "Press Start 2P", cursive; width: 100vw; height: 100vh; user-select: none; 
    }
    canvas { display: block; width: 100%; height: 100%; outline: none; }

    /* UI GLOBALE */
    .screen {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        text-align: center; color: white; z-index: 1000;
        background: radial-gradient(circle at center, #2c3e50 0%, #000000 100%);
    }
    
    h1 { 
        font-size: 32px; color: #fff; 
        text-shadow: 4px 4px 0 #000; 
        margin-bottom: 10px; line-height: 1.4;
        text-transform: uppercase;
        position: relative;
    }
    h1::after {
        content: ''; display: block; width: 100px; height: 6px; 
        background: #f1c40f; margin: 15px auto; 
        box-shadow: 0 0 10px #f1c40f;
    }

    .subtitle { 
        font-size: 12px; color: #aaa; letter-spacing: 3px; 
        margin-bottom: 40px; display: block; font-family: 'Roboto', sans-serif; font-weight: bold;
    }
    
    .info-radar {
        border: 2px solid rgba(255,255,255,0.1);
        background: rgba(0,0,0,0.6);
        padding: 20px 30px;
        margin-bottom: 40px;
        border-radius: 10px;
        backdrop-filter: blur(5px);
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        animation: float 3s ease-in-out infinite;
    }
    @keyframes float { 0%,100%{transform:translateY(0);} 50%{transform:translateY(-10px);} }

    .radar-label { color: #f1c40f; font-size: 10px; margin-bottom: 5px; display: block; }
    .radar-text { font-family: 'Roboto', sans-serif; font-size: 18px; color: #fff; font-weight: bold; letter-spacing: 1px; }
    
    .btn-start {
        padding: 20px 50px; font-size: 20px; font-family: "Press Start 2P"; 
        color: #fff; background: #2ecc71; border: none; border-radius: 50px; 
        cursor: pointer; box-shadow: 0 10px 20px rgba(46, 204, 113, 0.4); 
        transition: all 0.2s; text-transform: uppercase;
    }
    .btn-start:hover { transform: scale(1.05); box-shadow: 0 15px 30px rgba(46, 204, 113, 0.6); }
    .btn-start:active { transform: scale(0.95); }

    .credits-box {
        position: absolute; bottom: 20px; left: 20px;
        font-family: 'Roboto', sans-serif; text-align: left;
        color: rgba(255,255,255,0.5); font-size: 12px;
    }
    .credits-title { font-weight: bold; color: #f1c40f; margin-bottom: 5px; font-size: 10px; text-transform: uppercase; letter-spacing: 1px; }
    .credits-names { line-height: 1.4; font-size: 11px; }

    .btn-retry {
        padding: 15px 30px; font-size: 14px; font-family: "Press Start 2P"; 
        background: transparent; border: 2px solid white; color: white; cursor: pointer; margin-top: 20px;
    }
    .btn-retry:hover { background: white; color: black; }
    .btn-info { border: none; background: #8e44ad; border-radius: 5px; font-size: 14px; padding: 15px 30px; color: white; font-family: "Press Start 2P"; cursor: pointer;}

    .popup-overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.95); display: flex; justify-content: center; align-items: center;
        z-index: 2000; visibility: hidden;
    }
    .popup-box {
        background: white; padding: 30px; width: 85%; max-width: 450px;
        text-align: center; border-radius: 15px; box-shadow: 0 20px 50px rgba(0,0,0,0.5);
    }
    .fact-text { font-family: 'Roboto', sans-serif; font-size: 18px; color: #2c3e50; margin: 20px 0; line-height: 1.5; font-weight: bold; }
    .fact-source { font-family: 'Roboto', sans-serif; font-size: 12px; color: #7f8c8d; font-style: italic; display: block; margin-top: 10px; border-top: 1px solid #eee; padding-top: 10px;}

    #score-hud { position: absolute; top: 30px; left: 30px; z-index: 500; font-size: 30px; color: white; text-shadow: 3px 3px 0 #000; display: none; }
    
    #mobile-controls { position: absolute; bottom: 30px; width: 100%; display: flex; justify-content: center; z-index: 500; display: none; }
    .dpad { display: grid; grid-template-columns: 70px 70px 70px; gap: 10px; }
    .key { width: 70px; height: 70px; background: rgba(255,255,255,0.2); border: 2px solid white; border-radius: 10px; display: flex; justify-content: center; align-items: center; font-size: 30px; color: white; cursor: pointer; }
</style>
</head>
<body>

    <div id="loader" style="position:fixed;top:0;left:0;width:100%;height:100%;background:#1a1a2e;color:white;display:flex;justify-content:center;align-items:center;z-index:9999;">
        Chargement...
    </div>

    <div id="start-screen" class="screen">
        <div>
            <h1>CROSS<br>THE YELLOW LINE</h1>
            <span class="subtitle">UNE EXP√âRIENCE INTERACTIVE</span>
        </div>
        <div class="info-radar">
            <span class="radar-label">OBJECTIF DU SYST√àME</span>
            <span class="radar-text">ATTEINDRE LA LIGNE JAUNE (100)</span>
        </div>
        <button class="btn-start" onclick="lancerJeu()">JOUER</button>
        <div class="credits-box">
            <div class="credits-title">R√âALISATION</div>
            <div class="credits-names">
                Axel Pic<br>Pierre-Louis Gousset<br>Adrien Fang<br>Pierre.S
            </div>
        </div>
    </div>

    <div id="game-over-screen" class="screen" style="display:none;">
        <h1 style="color:#e74c3c; font-size:40px; text-shadow:none;">IMPACT !</h1>
        <p>Score: <span id="final-score">0</span></p>
        <div style="background:white; color:#333; padding:20px; border-radius:10px; margin-bottom:20px; font-family:'Roboto',sans-serif; font-size:14px; max-width:350px;">
            <strong style="color:#c0392b">RAPPEL IMPORTANT</strong><br><br>
            <span id="go-fact">...</span>
        </div>
        <button class="btn-retry" onclick="reloadPage()">MENU PRINCIPAL</button>
    </div>

    <div id="moral-fail-screen" class="screen" style="display:none;">
        <h1 style="color:#e74c3c; font-size:30px;">VOUS AVEZ SUIVI<br>LA SOCI√âT√â</h1>
        <div style="max-width:500px; padding:20px;">
            <p style="color:#e74c3c; font-size:20px; font-weight:bold;">Game Over.</p>
            <p style="color:#ccc; font-size:16px;">
                "Parfois, il faut aller √† l'encontre de la soci√©t√© pour que les choses changent. Ne suivez pas aveugl√©ment la ligne trac√©e."
            </p>
        </div>
        <button class="btn-retry" onclick="reloadPage()">MENU PRINCIPAL</button>
    </div>

    <div id="victory-screen" class="screen" style="display:none;">
        <h1 style="color:#2ecc71;">VICTOIRE CACH√âE</h1>
        <div style="font-size:80px; margin:20px">üö©</div>
        <p>Vous avez trouv√© le drapeau.<br>Refuser d'avancer quand la direction est mauvaise est un acte de courage.</p>
        <p style="font-size:12px; color:#aaa;">Score final : -20</p>
        <button class="btn-start" onclick="reloadPage()" style="margin-top:20px;">MENU PRINCIPAL</button>
    </div>

    <div id="popup-info" class="popup-overlay">
        <div class="popup-box">
            <h2 style="color:#8e44ad;margin:0;font-size:18px; margin-bottom:10px;">INFORMATION</h2>
            <div class="fact-text" id="info-fact">...</div>
            <span class="fact-source" id="info-source">...</span>
            <button class="btn-info" onclick="closeInfo()">JE COMPRENDS</button>
        </div>
    </div>

    <div id="score-hud">0</div>
    <div id="mobile-controls">
        <div class="dpad">
            <div class="key" style="grid-column:2" onmousedown="inputAction(0,1)" ontouchstart="inputAction(0,1)">‚ñ≤</div>
            <div class="key" style="grid-row:2" onmousedown="inputAction(-1,0)" ontouchstart="inputAction(-1,0)">‚óÄ</div>
            <div class="key" style="grid-row:2" onmousedown="inputAction(0,-1)" ontouchstart="inputAction(0,-1)">‚ñº</div>
            <div class="key" style="grid-row:2" onmousedown="inputAction(1,0)" ontouchstart="inputAction(1,0)">‚ñ∂</div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
window.onload = function() {
    if (typeof THREE === 'undefined') {
        document.getElementById('loader').innerHTML = "<p style='color:red'>Erreur : Three.js requis.</p>";
    } else {
        document.getElementById('loader').style.display = 'none';
        document.getElementById('start-screen').style.display = 'flex';
        if(/Android|iPhone|iPad/i.test(navigator.userAgent)) document.getElementById('mobile-controls').style.display = 'flex';
    }
};

const factsDB = [
    { t: "Une femme meurt tous les 3 jours sous les coups de son conjoint ou ex-conjoint.", s: "Source : Minist√®re de l'Int√©rieur" },
    { t: "Dans 91% des cas d'agressions sexuelles, la victime conna√Æt son agresseur (ami, famille, coll√®gue).", s: "Source : Enqu√™te VIRAGE (INED)" },
    { t: "La sid√©ration psychique emp√™che souvent la victime de crier ou de fuir. Ce silence n'est PAS un consentement.", s: "Source : M√©moire Traumatique et Victimologie" },
    { t: "100% des utilisatrices de transports en commun ont d√©j√† subi du harc√®lement sexiste ou sexuel.", s: "Source : HCEfh" },
    { t: "8 femmes sur 10 ont peur de rentrer seules le soir.", s: "Source : Sondage Ifop" },
    { t: "Siffler, suivre ou faire des commentaires sexuels dans la rue est un d√©lit puni par la loi (Outrage Sexiste).", s: "Source : Code P√©nal" },
    { t: "30% des salari√©es ont d√©j√† √©t√© harcel√©es ou agress√©es sexuellement sur leur lieu de travail.", s: "Source : Ifop / D√©fenseur des droits" },
    { t: "Exiger les mots de passe ou g√©olocaliser sa partenaire n'est pas de l'amour, c'est de la violence psychologique.", s: "Source : Centre Hubertine Auclert" },
    { t: "Diffuser des photos intimes sans accord (revenge porn) est un d√©lit puni de 2 ans de prison.", s: "Source : Article 226-1 du Code P√©nal" },
    { t: "Le consentement doit √™tre libre, √©clair√© et enthousiaste. L'absence de 'non' ne vaut pas 'oui'.", s: "Source : Amnesty International" },
    { t: "La tenue vestimentaire n'est jamais une invitation au viol. La seule cause du viol, c'est le violeur.", s: "Source : Collectif #NousToutes" },
    { t: "L'alcool ou la drogue ne sont pas des excuses pour l'agresseur, ce sont des circonstances aggravantes.", s: "Source : Minist√®re de la Justice" },
    { t: "Besoin d'aide ? Le 3919 est anonyme, gratuit et n'appara√Æt pas sur les factures t√©l√©phoniques.", s: "Source : Service-Public.fr" }
];

const CONFIG = { TILE: 40, WIDTH: 21, YELLOW_LINE: 100, BACK_WIN: -20 };
let scene, camera, renderer, player, mapGroup;
let gameState = 'MENU';
let score = 0;
const OFFSET = 200; 
let lanes = []; 
let currentPos = { x: 0, y: 0 };
let isMoving = false;
let moveQueue = null;
const clock = new THREE.Clock();
let audioCtx = null;
let holos = []; 

// GESTION JEU
window.lancerJeu = function() {
    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('score-hud').style.display = 'block';
    
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();

    if(!renderer) {
        initThreeJS();
    } else {
        resetGame();
    }
};

window.reloadPage = function() {
    window.location.reload();
};

function initThreeJS() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x2c3e50);

    const aspect = window.innerWidth / window.innerHeight;
    const d = 300;
    camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
    camera.position.set(300, 300, 300);
    camera.lookAt(0, 0, 0);

    const canvas = document.getElementById('gameCanvas');
    renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.capabilities.getMaxAnisotropy();

    const ambient = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambient);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
    dirLight.position.set(100, 200, 100);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
    dirLight.shadow.camera.left = -500; dirLight.shadow.camera.right = 500;
    dirLight.shadow.camera.top = 500; dirLight.shadow.camera.bottom = -500;
    scene.add(dirLight);

    mapGroup = new THREE.Group();
    scene.add(mapGroup);
    
    createPlayer();
    // PLUS DE PANNEAU ICI
    createHolos(); 
    resetGame();
    animate();

    window.addEventListener('resize', onResize);
    window.addEventListener('keydown', onKeyDown);
}

// --- FL√àCHES AU SOL UNIQUEMENT ---
function createHolos() {
    const canvas = document.createElement('canvas');
    canvas.width = 128; canvas.height = 128;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ff0000'; // ROUGE
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = 'bold 100px Arial'; 
    ctx.fillText('‚¨Ü', 64, 64); // UNE SEULE GROSSE FL√àCHE

    const texture = new THREE.CanvasTexture(canvas);

    const geo = new THREE.PlaneGeometry(30, 30);
    const mat = new THREE.MeshBasicMaterial({ 
        map: texture,
        transparent: true, 
        opacity: 0.8,
        side: THREE.DoubleSide,
        depthWrite: false
    });

    // LIGNES 2, 4, 6, 8 SEULEMENT
    for(let i=2; i<=8; i+=2) {
        const holo = new THREE.Mesh(geo, mat);
        holo.position.set(0, 5, -i * CONFIG.TILE); 
        holo.rotation.x = -Math.PI / 2; // A plat
        scene.add(holo);
        holos.push({ mesh: holo, baseY: 5 });
    }
}

function createPlayer() {
    player = new THREE.Group();
    const matWhite = new THREE.MeshLambertMaterial({ color: 0xffffff });
    const matRed = new THREE.MeshLambertMaterial({ color: 0xe74c3c });
    const matOrange = new THREE.MeshLambertMaterial({ color: 0xf39c12 });

    const body = new THREE.Mesh(new THREE.BoxGeometry(22,22,22), matWhite);
    body.position.y = 11; body.castShadow = true;
    const crest = new THREE.Mesh(new THREE.BoxGeometry(6,8,10), matRed);
    crest.position.set(0, 24, 4);
    const beak = new THREE.Mesh(new THREE.BoxGeometry(8,6,6), matOrange);
    beak.position.set(0, 14, 12);

    player.add(body); player.add(crest); player.add(beak);
    scene.add(player);
}

function resetGame() {
    gameState = 'PLAYING';
    score = 0;
    currentPos = { x: 0, y: 0 };
    isMoving = false;
    moveQueue = null;
    lanes = []; 
    
    document.getElementById('score-hud').innerText = "0";
    
    while(mapGroup.children.length > 0){ mapGroup.remove(mapGroup.children[0]); }
    player.position.set(0,0,0);
    player.rotation.y = 0;
    camera.position.set(300, 300, 300);
    camera.lookAt(0, 0, 0);

    for(let i = -30; i < 120; i++) spawnLane(i);
}

function spawnLane(index) {
    let type = 'grass';
    if (index === CONFIG.YELLOW_LINE) type = 'yellow_line';
    else if (index === CONFIG.BACK_WIN) type = 'flag_zone'; 
    else if (index < 3) type = 'grass_safe';
    else {
        const rand = Math.random();
        if(rand < 0.2) type = 'checkpoint';
        else if(rand < 0.5) type = 'grass';
        else if(rand < 0.75) type = 'road_car';
        else type = 'road_truck';
    }

    const lane = { type:type, mesh: new THREE.Group(), vehicles:[], obstacles:[] };
    lane.mesh.position.z = -index * CONFIG.TILE;
    lane.mesh.position.y = 0;

    let color = 0x76c442;
    if(index % 2 !== 0 && (type.includes('grass') || type === 'flag_zone')) color = 0x93d661;
    if(type.includes('road')) color = 0x555555;
    if(type === 'yellow_line') color = 0xf1c40f;

    const floor = new THREE.Mesh(new THREE.BoxGeometry(1000, 40, CONFIG.TILE), new THREE.MeshLambertMaterial({ color: color }));
    floor.position.y = -20; floor.receiveShadow = true;
    lane.mesh.add(floor);

    if (type === 'flag_zone') {
        const flagGroup = new THREE.Group();
        const pole = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 60), new THREE.MeshLambertMaterial({color:0x888888}));
        pole.position.y = 30;
        const flag = new THREE.Mesh(new THREE.BoxGeometry(20, 15, 2), new THREE.MeshLambertMaterial({color:0xe74c3c}));
        flag.position.set(10, 50, 0);
        flagGroup.add(pole); flagGroup.add(flag);
        flagGroup.position.set(0, 0, 0); 
        flagGroup.castShadow = true;
        lane.mesh.add(flagGroup);
        lane.flag = { x: 0, collected: false }; 
    }
    else if(type === 'grass') {
        const count = Math.floor(Math.random()*3);
        for(let k=0; k<count; k++){
            const x = Math.floor(Math.random()*CONFIG.WIDTH) - Math.floor(CONFIG.WIDTH/2);
            if(x===0) continue; 
            const g = new THREE.Group();
            const trunk = new THREE.Mesh(new THREE.BoxGeometry(10,20,10), new THREE.MeshLambertMaterial({color:0x795548}));
            trunk.position.y = 10;
            const l1 = new THREE.Mesh(new THREE.BoxGeometry(26,12,26), new THREE.MeshLambertMaterial({color:0x27ae60}));
            l1.position.y=20;
            const l2 = new THREE.Mesh(new THREE.BoxGeometry(20,12,20), new THREE.MeshLambertMaterial({color:0x2ecc71}));
            l2.position.y=30;
            g.add(trunk); g.add(l1); g.add(l2); g.castShadow=true;
            g.position.x = x * CONFIG.TILE;
            lane.mesh.add(g);
            lane.obstacles.push(x);
        }
    } 
    else if(type === 'checkpoint') {
        const x = Math.floor(Math.random()*6)-3;
        const box = new THREE.Mesh(new THREE.BoxGeometry(18,18,18), new THREE.MeshLambertMaterial({color:0x9b59b6}));
        box.position.set(x*CONFIG.TILE, 15, 0); box.rotation.x = Math.PI/4; box.rotation.z = Math.PI/4;
        lane.mesh.add(box);
        lane.checkpoint = { x:x, collected:false, mesh:box };
    } 
    else if(type.includes('road')) {
        lane.speed = 90 + Math.random()*80;
        lane.dir = Math.random()>0.5 ? 1 : -1;
        const isTruck = type.includes('truck');
        const count = isTruck ? 2 : 3;
        const spacing = 250 + Math.random()*150;
        for(let i=0; i<count; i++){
            const colorVeh = isTruck ? 0xe74c3c : 0x3498db;
            const g = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(isTruck?50:40, isTruck?18:14, 18), new THREE.MeshLambertMaterial({color:colorVeh}));
            body.position.y = isTruck?9:7; body.castShadow=true;
            const top = new THREE.Mesh(new THREE.BoxGeometry(isTruck?15:24, isTruck?18:8, 16), new THREE.MeshLambertMaterial({color:isTruck?0xffffff:0xecf0f1}));
            top.position.set(isTruck?20:0, isTruck?18:14, 0);
            g.add(body); g.add(top);
            g.position.x = i*spacing*lane.dir;
            if(lane.dir === -1) g.rotation.y = Math.PI;
            lane.mesh.add(g);
            lane.vehicles.push(g);
        }
    }
    mapGroup.add(lane.mesh);
    lanes[index + OFFSET] = lane;
}

function animate() {
    if(gameState === 'PLAYING') {
        const delta = clock.getDelta();
        const time = Date.now() * 0.005;
        
        // ANIMATION : Pulsation sur place uniquement
        holos.forEach((h, index) => {
            h.mesh.position.y = h.baseY + Math.sin(time * 3 + index) * 2;
            const s = 1 + Math.sin(time * 5 + index) * 0.1;
            h.mesh.scale.set(s, s, s);
        });
        
        for(let i = currentPos.y - 15; i < currentPos.y + 20; i++){
            const lane = lanes[i + OFFSET];
            if(!lane) continue;
            if(lane.checkpoint && !lane.checkpoint.collected) {
                lane.checkpoint.mesh.rotation.y += delta*2;
                lane.checkpoint.mesh.position.y = 15 + Math.sin(Date.now()*0.005)*2;
            }
            if(lane.vehicles.length > 0) {
                lane.vehicles.forEach(v => {
                    v.position.x += lane.speed * delta * lane.dir;
                    if(lane.dir===1 && v.position.x > 500) v.position.x = -500;
                    if(lane.dir===-1 && v.position.x < -500) v.position.x = 500;
                    if(i === currentPos.y) {
                        const dist = Math.abs(v.position.x - (currentPos.x * CONFIG.TILE));
                        if(dist < 32) doGameOver();
                    }
                });
            }
        }

        if(moveQueue) {
            moveQueue.t += delta * 6;
            if(moveQueue.t >= 1) {
                updatePlayerPos(moveQueue.start, moveQueue.end, 1);
                isMoving = false;
                currentPos.x = moveQueue.tx; currentPos.y = moveQueue.ty;
                
                if (currentPos.y >= CONFIG.YELLOW_LINE) {
                    doMoralFail();
                } else {
                    checkEvents();
                    moveQueue = null;
                    const maxIdx = (lanes.length - OFFSET) - 1; 
                    if(currentPos.y > maxIdx - 20) spawnLane(maxIdx + 1);
                }
            } else {
                updatePlayerPos(moveQueue.start, moveQueue.end, moveQueue.t);
            }
        }

        const tZ = -(currentPos.y * CONFIG.TILE) + 300; 
        const tX = (currentPos.x * CONFIG.TILE) + 300;
        camera.position.z += (tZ - camera.position.z) * 0.1;
        camera.position.x += (tX - camera.position.x) * 0.1;
    }
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}

function updatePlayerPos(s, e, t) {
    player.position.x = s.x + (e.x - s.x)*t;
    player.position.z = s.z + (e.z - s.z)*t;
    player.position.y = 11 + Math.sin(t*Math.PI)*20; 
    player.rotation.z = Math.sin(t*Math.PI) * 0.1 * (Math.random()>0.5?1:-1);
}

window.inputAction = function(dx, dy) {
    if(gameState !== 'PLAYING' || isMoving) return;
    const nx = currentPos.x + dx;
    const ny = currentPos.y + dy;
    if(Math.abs(nx) > 10) return;
    
    const lane = lanes[ny + OFFSET];
    if(lane && lane.obstacles.includes(nx)) return;

    isMoving = true;
    playSound('move');
    if(dx===1) player.rotation.y = -Math.PI/2;
    else if(dx===-1) player.rotation.y = Math.PI/2;
    else if(dy===1) player.rotation.y = 0;
    else if(dy===-1) player.rotation.y = Math.PI;

    const start = player.position.clone();
    const end = new THREE.Vector3(nx * CONFIG.TILE, 11, -ny * CONFIG.TILE);
    moveQueue = { start:start, end:end, tx:nx, ty:ny, t:0 };
    score = ny; 
    document.getElementById('score-hud').innerText = score;
};

window.addEventListener('keydown', (e) => {
    if(e.repeat) return;
    if(e.key==='ArrowUp') inputAction(0,1);
    if(e.key==='ArrowDown') inputAction(0,-1);
    if(e.key==='ArrowLeft') inputAction(-1,0);
    if(e.key==='ArrowRight') inputAction(1,0);
});

function checkEvents() {
    const l = lanes[currentPos.y + OFFSET];
    if(!l) return;

    if(l.checkpoint && !l.checkpoint.collected && l.checkpoint.x === currentPos.x) {
        l.checkpoint.collected = true;
        l.checkpoint.mesh.visible = false;
        gameState = 'PAUSED';
        playSound('checkpoint');
        const f = factsDB[Math.floor(Math.random()*factsDB.length)];
        document.getElementById('info-fact').innerText = f.t;
        document.getElementById('info-source').innerText = f.s;
        document.getElementById('popup-info').style.visibility = 'visible';
    }

    if(l.flag && !l.flag.collected && l.flag.x === currentPos.x) {
        doRealVictory();
    }
}

window.closeInfo = function() {
    document.getElementById('popup-info').style.visibility = 'hidden';
    gameState = 'PLAYING';
};

function doGameOver() {
    gameState = 'GAME_OVER';
    playSound('crash');
    document.getElementById('final-score').innerText = score;
    const f = factsDB[Math.floor(Math.random()*factsDB.length)];
    document.getElementById('go-fact').innerText = f.t;
    document.getElementById('game-over-screen').style.display = 'flex';
}

function doMoralFail() {
    gameState = 'GAME_OVER';
    playSound('crash');
    document.getElementById('moral-fail-screen').style.display = 'flex';
    document.getElementById('game-ui').style.display = 'none';
}

function doRealVictory() {
    gameState = 'WIN';
    playSound('win');
    document.getElementById('victory-screen').style.display = 'flex';
    document.getElementById('game-ui').style.display = 'none';
}

function playSound(type) {
    if(!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);
    const t = audioCtx.currentTime;
    
    if(type==='move'){
        const randomPitch = Math.random() * 50 - 25; 
        o.type = 'sine';
        o.frequency.setValueAtTime(300 + randomPitch, t);
        o.frequency.exponentialRampToValueAtTime(500 + randomPitch, t + 0.1);
        g.gain.setValueAtTime(0.1, t);
        g.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
        o.start(t); o.stop(t+0.1);
    } 
    else if(type==='crash'){ 
        o.type='square'; 
        const notes = [
            {f:493,d:0.1}, {f:698,d:0.1}, {f:0,d:0.05}, {f:698,d:0.1}, 
            {f:698,d:0.15}, {f:659,d:0.15}, {f:587,d:0.15}, {f:523,d:0.2}
        ];
        let now = t;
        notes.forEach(n => {
            if(n.f > 0){
                const o2 = audioCtx.createOscillator(); const g2 = audioCtx.createGain();
                o2.connect(g2); g2.connect(audioCtx.destination);
                o2.type='square'; o2.frequency.value = n.f;
                g2.gain.setValueAtTime(0.1, now); g2.gain.linearRampToValueAtTime(0, now+n.d-0.01);
                o2.start(now); o2.stop(now+n.d);
            }
            now += n.d;
        });
    } 
    else if(type==='checkpoint'){
        o.type='sine'; o.frequency.setValueAtTime(600,t); o.frequency.setValueAtTime(1000,t+0.1);
        g.gain.setValueAtTime(0.1,t); g.gain.linearRampToValueAtTime(0,t+0.3);
        o.start(t); o.stop(t+0.3);
    } 
    else if(type==='win'){ 
        const notes = [
            {f:392,d:0.1}, {f:523,d:0.1}, {f:659,d:0.1}, {f:784,d:0.1}, 
            {f:1046,d:0.1}, {f:1568,d:0.4}
        ];
        let now = t;
        notes.forEach(n => {
            const o2 = audioCtx.createOscillator(); const g2 = audioCtx.createGain();
            o2.connect(g2); g2.connect(audioCtx.destination);
            o2.type='triangle'; o2.frequency.value = n.f;
            g2.gain.setValueAtTime(0.1, now); g2.gain.linearRampToValueAtTime(0, now+n.d);
            o2.start(now); o2.stop(now+n.d);
            now += n.d;
        });
    }
}

function onResize() {
    if(!camera) return;
    const aspect = window.innerWidth / window.innerHeight;
    const d = 300;
    camera.left = -d * aspect; camera.right = d * aspect;
    camera.top = d; camera.bottom = -d;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}
</script>
</body>
</html>
